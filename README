/ 
*******************************************************************************
* PROJ 3: Zap
* Comp 15 November 17th 2022
* README
* Author: Hazel Scullin - hscull01
*******************************************************************************
/

Program Purpose:
---------------
    The purpose of this program is to compress and decompress text files 
    using the Huffman coding algorithm. In other words, the program
    reduces the number of bits neded to represent the data in a text file. 
    The program also has the ability to reverse the compression of data. It 
    restores a previously zapped file inputFil by decompressing it, and storing
    the resulting ASCII text.

Compile/run:
-----------
    Compile using
        make zap

    Run executable with
        ./zap

Acknowledgments:
---------------
    Harrison Sweet for suggesting I write my decode tree function as a for
    loop instead of recursively as I was trying to do. 

Files:
-----

unit_tests.h: A testing file for the HuffmanCoder Class. 
    Tests individual functions for errors and runs valgrind. 

Makefile: File to build the program and link the according files 

HuffmanCoder.h: This is the interface for the HuffmanCoder class. 
    The HuffmanCoder class allows for the compression and decompression 
    of text files. To do so it follows much of the logic of a Huffman 
    coding algorithm. The class has two main functions in within it. 
    One for "zapping" the text by compressing it and one for "unzapping" 
    by decompressing both of which enlist the help of a huffman tree.

HuffmanCoder.cpp: This is the implementation for the HuffmanCoder class. 
    The HuffmanCoder class allows for the compression and decompression 
    of text files. To do so it follows much of the logic of a Huffman 
    coding algorithm. The class has two main functions in within it. 
    One for "zapping" the text by compressing it and one for "unzapping" 
    by decompressing both of which enlist the help of a huffman tree. 
    To support these main encoding and decoding functions are helper 
    functions that cover the individual steps. Theres one for counting 
    the number of instances of a charcter. Theres a function for creatign 
    a huffman tree. Theres also a function for following the huffman tree 
    to decode the binary sequence for unzapping the file.

main.cpp
    The purpose of this file is to create and run one instance of the
    HuffmanCoder class.

BinaryIO.h
    a provided file which controlls reading and writing to another file.

banana_output.txt
    the output file from my code of the zap being called on banana.txt 

hi_output.txt
    the output file from my code of the zap being called on hi.txt

banana_apple_output.txt
    the output file from my code of the zap being called on banana_apple.txt

sentences_output.txt
    the output file from my code of the zap being called on sentences.txt

all_conll_english_output.txt
    the output file from my code of the zap being called on 
    all_conll_english.txt

works_of_shakespeare_output.txt
    the output file from my code of the zap being called on 
    works_of_shakespeare.txt

ecoli.coli
    the output file from my code of the zap being called on ecoli.coli

new_banana.txt
    the output file from my code of the unzap command being called on 
    banana_output.txt used for diff testing

new_ecoli.txt 
    the output file from my code of the unzap command being called on 
    ecoli_output.txt used for diff testing

Data Structures:
--------------- 

    The most obvious data structure at work in this program is a 
    tree. In this program a tree is used to generate character codes
    for compression and for decoding a binary string for decompression. 
    I chose this data structure because the assignment asks that we use
    the huffman coding algorithm to produce compressed and decompressed
    files. Trees are valuable for character coding becuase ecoding is done 
    using the same tree. This will remove ambiguity and errors form the 
    decoding process. Additionally, using a tree and huffman algorithms
    means that code associated with each character should not be present 
    in the prefix of any other character's code.

    I used queues when creating the priority queue. There is a priority 
    queue of HuffmanTreeNode pointers, which is represented under the 
    hood using a vector, and uses the comparator function defined. I used the
    priority queue to help construct my huffman trees. The priority queue
    is basically a queue where the minimum value is at the front of the 
    queue, that way I could use it to connect nodes with minimum values for 
    the huffman tree more easily. In other words, the top of the queue is 
    the priority and can removed easily. 

    I also used a vector, or an array, to store the character frequencies
    for the given text. 
    Additionally, I made the array the same size as there are ASCII characters
    so I could store the number of instances under the spot in the array that
    corresponded to their ASCII value. This allowed me to access them very 
    easily. That means you can also use a char in contexts where an 
    integer was expected and the reverse of that too. I believe an array was
    the right choice because of constant time access. I knew the array wouldnt
    need to change size so i thought it would be best for both logic 
    and time and space complexity. 

    An algorithm I relied on to make this code was the function
    for decoding the tree. I used a for loop to contstruct it and stored 
    the root in a variable before the loop begins. I then iterated through the 
    binary string and traversed the tree accordingly moving left when 
    I encountered zeros and right when i encountered ones. The for loop
    helped me keep track of where i was in the binary string while resetting 
    the node of the tree. 
    I also used a big recursive function to build my huffman tree. I 
    kept track of the count that allowed me to access the characters in the 
    string of the serialized tree. Then depending on the serialized 
    input i would either add a leaf or an internal node. 


Testing:
-------
    In unit_test I first tested my count_freqs function and and thought it 
    was wrong on my first try, but then I remembered that the output wont 
    be identical to that of the zap program you gave me. 

    When writing/testing my deserialize function I ran into an error stating 
    that the monitored xommand dumped core. To debug I wrote a whole bunch 
    of print statements tracking the variables in my build function that 
    supports the deserialize tree function. The issue was that I forgot to 
    dereference the count variable i had passed into the function, so i was 
    adding to the location where count was stored rather than the value of 
    the count variable. 
    My testing print statements were:
        cout << "our tree is " << serial_tree << endl;
        cout << "entered" << endl;
        cout << "count is " << *count << endl;
    and i put it at the beginning of my build function.


    for testing count_freqs cout
    << node->get_val() << " " << node->get_freq() << endl;
    in the function to make sure that all of my newly constructed nodes 
    contained the right characters and frequencies stored in them

    for testing that my tree was constructed correctly I did a horribly 
    inefficient printing job using the following statements 
        cout << "root : ";
    cout << primary_root->get_freq() << endl;
    cout << "first node on left : ";
    cout << primary_root->get_left()->get_freq() << endl;
    cout << primary_root->get_left()->get_val() << endl;
    cout << "first node on right : ";
    cout << primary_root->get_right()->get_freq() << endl;
    etc etc

    I also had a segmentation fault in my unzap function which I solved
    using a bunch of print statements like above. It looks as follows

    zapped_file_info = reader.readFile(input_file);
    cout << "read from file" << endl;

    string serialized_tree = zapped_file_info[0];
    cout << "serialized tree" << endl;
    encoded_text = zapped_file_info[1];
    cout << "encoded text" << endl;

    HuffmanTreeNode *root = deserialize_tree(serialized_tree);
    cout << "deserialized tree" << endl;

    open_or_die(output_file_stream, output_file);
    cout << "opened out file" << endl;

    decode_tree(root);
    cout << "decoded tree" << endl;
    delete_tree(root);
    cout << "deldete tree" << endl;

    This allowed me to follow along in each step of my program to see where
    the program was getting stuck and it turned out that my program was stuck 
    in my decode tree function so I put even more print statements inside to 
    see when a nodes value was given vs when the function followed a node to 
    the left or to the right. The issue had to do with me tryign to make the 
    funciton a recursive one. I changed it to a for loop and all my seg 
    faults were gone!

    For the latter stages of my testing I ran my code and then the ./the_zap 
    with the same input and output files and compared each of the results
    manually for the encoder portion. I was able to do this just by compring
    the print statements made by each function. And then I diff tested the 
    decoder functions comparing my code with the_zap once again. 

Hours:
-------
    Phase 1: 6 hours
    Phase 2: 20 hours
